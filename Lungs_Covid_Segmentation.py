# -*- coding: utf-8 -*-
"""PROJECT_4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1S5KAwl-hdZZvhvcyebJEqjir6kMt4HfM

**README.txt**

1. Folder structure:
    * **image**: 150 CT scans indexed from 0 to 149. Each CT scan folder contains frame jpg files indexed in a serial order.
    * **mask**: 150 CT scans indexed from 0 to 149. Each mask folder contains annotation png files for the frame jpg file with the same filename and the same CT scan index.

2. Annotation and image file explanation:

    Frame jpg files and the corresponding mask png files are all with a resolution of 512X512.
    Each pixel of a mask png file is a uint number ranged from 0 to 3 represents the pixel-wised label for the corresponding frame jpg file.
    The meaning of label from 0 to 3 are as follow:
        0: Background (BG)
        1: Lung field (LF)
        2: Ground-glass opacity (GGO)
        3: Consolidation (CO)

#STUDIO INIZIALE DEL DATASET

##1. Import dati

Importiamo le librerie di base e scarico le immagini e le mask
"""

import os
import time
import shutil
import numpy as np
import matplotlib.pyplot as plt
import cv2

import torch
from torchsummary import summary
from torch.utils.data import Dataset
import torchvision

from torch import nn, optim
import torch.nn.functional as F
from torchvision import datasets, transforms, models

from PIL import Image
from zipfile import ZipFile

"""###Eseguire la seguente cella se non si ha su Google Drive il file *ct_lesion_seg.zip*"""

#!rm -rf ct_lesion_seg.zip           #eseguire solo per la consegna
#!rm -rf ct_lesion_seg
#!wget http://giagu.web.cern.ch/giagu/CERN/ct_lesion_seg.zip
#!unzip -q ct_lesion_seg.zip
#!rm -rf __MACOSX

"""###Eseguire la seguente cella se si ha il file salvato su Drive (in folder "MACHINE LEARNING")"""

from google.colab import drive
drive.mount('/content/drive')

file_name = "/content/drive/My Drive/MACHINE LEARNING/ct_lesion_seg.zip" #Leggo il file.zip dalla cartella su Drive
with ZipFile(file_name, 'r') as zap:

    zap.printdir()
    zap.extractall()

"""##2. Costruiamo i dataset image e mask"""

for i in os.listdir("/content/ct_lesion_seg/"):
    if (i == "imagecut"):
      shutil.rmtree("/content/ct_lesion_seg/imagecut")
os.mkdir("/content/ct_lesion_seg/imagecut")
dir = os.listdir("ct_lesion_seg/mask")
dir.sort()
dir = dir[1:]
paths = []
image_path="/content/ct_lesion_seg/imagecut/"
mask_path="/content/ct_lesion_seg/mask/"
for i in range(len(dir)):
    os.mkdir("/content/ct_lesion_seg/imagecut/" + dir[i])
    paths.append("ct_lesion_seg/mask/" + dir[i])

    files = os.listdir(paths[i])
    files.sort()
    for filename in files:
        filename = os.path.splitext(filename)[0]
        imagepath = "/content/ct_lesion_seg/image/" + dir[i] + "/" + filename + ".jpg"
        imagecutpath = "/content/ct_lesion_seg/imagecut/" + dir[i]
        shutil.copy(imagepath, imagecutpath)

"""Riportiamo il campione da RGB a scala di grigi e controlliamo di non modificare i dati in questa trasformazione"""

#Import immagine con la scala di grigi e normalizzazione
im_ms_transforms = transforms.Compose([transforms.Resize((512,512)),
                                       transforms.ToTensor(),
                                       transforms.Grayscale(num_output_channels=1),
                                       transforms.Normalize(mean=(0),std=(1,))
                                       ])

image = datasets.ImageFolder('/content/ct_lesion_seg/imagecut', transform=im_ms_transforms)
mask = datasets.ImageFolder('/content/ct_lesion_seg/mask', transform=im_ms_transforms)

mask_transforms_1 = transforms.Compose([transforms.Resize((512,512)),
                                         transforms.ToTensor(),
                                      ])

mask_1 = datasets.ImageFolder('/content/ct_lesion_seg/mask', transform=mask_transforms_1)
print(image, mask)
print(mask_1)

"""##3. Display image e mask

###Controllo mask
"""

figure = plt.figure(figsize=(10, 8))
cols, rows = 2,3
for i in range(1, rows +1  ):
    sample_idx = torch.randint(len(image), size=(1,)).item()
    img,label = mask[sample_idx] #le label indicano il numero del paziente
    figure.add_subplot(rows, cols, 2*i-1)
    plt.title(label)
    plt.axis("off")
    plt.imshow(img.squeeze(), cmap="gray", vmax=0.011)     #inseriamo un vmax per evitare che cmap normalizzi i colori come [0,1]
    img2,label2 = mask_1[sample_idx]

    figure.add_subplot(rows, cols, 2*i)
    plt.axis("off")
    plt.title(label2)
    plt.imshow(img2.permute(1,2,0)*85)
plt.show()

"""**Nota**: Le *mask* plottate con il dataloader in RGB e con il dataloader in *Grayscale* sono le stesse, tuttavia *cmap* fornisce valori in ordine crescente di intensità. Questo potrebbe attribuire valori differenti alle mask ottenute nei diversi modi. Controlliamo per sicurezza che le mask siano le stesse:"""

import random
ind=random.randint(0,511)
for i in (0,511):
  for j in (0,511):
    if(mask[ind][0][0][i][j]!=mask_1[ind][0][0][i][j]):
      print('errore')

"""Non ho errori, le mask sono dunque le stesse

###Controllo image
"""

figure = plt.figure(figsize=(10, 8))
cols, rows = 2,3
for i in range(1, rows +1  ):
    sample_idx = torch.randint(len(image), size=(1,)).item()
    img, label = image[sample_idx] #le label indicano il numero del paziente
    img2, label2 = mask[sample_idx]
    figure.add_subplot(rows, cols, 2*i-1)
    plt.title(label)
    plt.axis("off")
    plt.imshow(img.squeeze(), cmap="gray")
    figure.add_subplot(rows, cols, 2*i)
    plt.title(label2)
    plt.axis("off")
    plt.imshow(img2.squeeze(), cmap="gray", vmax=0.011)
plt.show()

"""#DATA AUGMENTATION"""

from torchvision import transforms
from albumentations import HorizontalFlip, VerticalFlip, Rotate

# Augment training data
train_transforms_1 = transforms.Compose([
    transforms.RandomHorizontalFlip(p=1),
    transforms.ToTensor(),
    transforms.Grayscale(num_output_channels=1),
    transforms.Normalize(mean=(0),std=(1,))
])

train_transforms_2 = transforms.Compose([
    transforms.RandomVerticalFlip(p=1.0),
    transforms.ToTensor(), transforms.Grayscale(num_output_channels=1),
    transforms.Normalize(mean=(0),std=(1,))
])

train_transforms_3 = transforms.Compose([
    transforms.RandomRotation(degrees=(45,45)),
    transforms.ToTensor(), transforms.Grayscale(num_output_channels=1),
    transforms.Normalize(mean=(0),std=(1,))
])

test_transforms = transforms.Compose([
    transforms.ToTensor(), transforms.Grayscale(num_output_channels=1)
])

#Flip orizzontale
image_1 = datasets.ImageFolder(image_path, transform=train_transforms_1)
mask_1 = datasets.ImageFolder(mask_path, transform=train_transforms_1)

#Flip verticale
image_2 = datasets.ImageFolder(image_path, transform=train_transforms_2)
mask_2 = datasets.ImageFolder(mask_path, transform=train_transforms_2)

#Rotazione di 45°
image_3 = datasets.ImageFolder(image_path, transform=train_transforms_3)
mask_3 = datasets.ImageFolder(mask_path, transform=train_transforms_3)

"""##Plot di alcune immagini post data-augmentation

###image_1 (flip orizzontale)
"""

figure = plt.figure(figsize=(10, 8))
cols, rows = 2,3
for i in range(1, rows +1  ):
    sample_idx = torch.randint(len(image_1), size=(1,)).item()
    img, label = image_1[sample_idx] #le label indicano il numero del paziente
    img2, label2 = mask_1[sample_idx]
    figure.add_subplot(rows, cols, 2*i-1)
    plt.title(label)
    plt.axis("off")
    plt.imshow(img.squeeze(), cmap="gray")
    figure.add_subplot(rows, cols, 2*i)
    plt.title(label2)
    plt.axis("off")
    plt.imshow(img2.squeeze(), cmap="gray", vmax=0.011)
plt.show()

"""###image_2 (flip verticale)"""

figure = plt.figure(figsize=(10, 8))
cols, rows = 2,3
for i in range(1, rows +1  ):
    sample_idx = torch.randint(len(image_2), size=(1,)).item()
    img, label = image_2[sample_idx] #le label indicano il numero del paziente
    img2, label2 = mask_2[sample_idx]
    figure.add_subplot(rows, cols, 2*i-1)
    plt.title(label)
    plt.axis("off")
    plt.imshow(img.squeeze(), cmap="gray")
    figure.add_subplot(rows, cols, 2*i)
    plt.title(label2)
    plt.axis("off")
    plt.imshow(img2.squeeze(), cmap="gray", vmax=0.011)
plt.show()

"""###image_3 (45° rotation)"""

figure = plt.figure(figsize=(10, 8))
cols, rows = 2,3
for i in range(1, rows +1  ):
    sample_idx = torch.randint(len(image_3), size=(1,)).item()
    img, label = image_3[sample_idx] #le label indicano il numero del paziente
    img2, label2 = mask_3[sample_idx]
    figure.add_subplot(rows, cols, 2*i-1)
    plt.title(label)
    plt.axis("off")
    plt.imshow(img.squeeze(), cmap="gray")
    figure.add_subplot(rows, cols, 2*i)
    plt.title(label2)
    plt.axis("off")
    plt.imshow(img2.squeeze(), cmap="gray", vmax=0.011)
plt.show()

"""#SPLIT (TRAIN - TEST - VALIDATION) e COSTRUZIONE DATALOADERS

##1. Concatenazione
Per prima cosa concateniamo i vari dataset in uno unico per image (IMAGE) e mask (MASK)

Selezioniamo solo le immagini e le mask, scartando le label
"""

image_a=[]
for i in range(len(image)):
  image_a.append(image[i][0])

image_b=[]
for i in range(len(image)):
  image_a.append(image_1[i][0])

image_c=[]
for i in range(len(image_2)):
  image_c.append(image_2[i][0])

image_d=[]
for i in range(len(image_3)):
  image_d.append(image_3[i][0])

"""Trasformiamo le mask da un tensore *torch.float32* ad un *torch.int32*, prima di farlo le riscaliamo in un range $[0,3]$"""

mask_a=[]
for i in range(len(mask)):
  mask_a.append((mask[i][0][0]/0.0117*3.5).type(torch.int))

mask_b=[]
for i in range(len(mask)):
  mask_b.append((mask_1[i][0][0]/0.0117*3.5).type(torch.int))

mask_c=[]
for i in range(len(mask)):
  mask_c.append((mask_2[i][0][0]/0.0117*3.5).type(torch.int))

mask_d=[]
for i in range(len(mask)):
  mask_d.append((mask_3[i][0][0]/0.0117*3.5).type(torch.int))

IMAGE = torch.utils.data.ConcatDataset([image_a, image_b, image_c, image_d])
MASK = torch.utils.data.ConcatDataset([mask_a, mask_b, mask_c, mask_d])
print(len(IMAGE))
print(len(MASK))

"""Si verifica come la concatenazione sia andata a buon fine; difatti len = 750 $\times$ 4 = 3000

Controlliamo che IMAGE e MASK siano delle dimensioni desiderate
"""

print(next(iter(IMAGE)).shape)
print(next(iter(MASK)).shape)

"""###Test grafico"""

figure = plt.figure(figsize=(10, 13))
cols, rows = 2,5
for i in range(1, rows +1  ):
    sample_idx = torch.randint(high=len(IMAGE), low=0, size=(1,)).item()
    img = IMAGE[sample_idx]
    img2 = MASK[sample_idx]
    figure.add_subplot(rows, cols, 2*i-1)
    plt.axis("off")
    plt.imshow(img.squeeze(), cmap="gray")
    figure.add_subplot(rows, cols, 2*i)
    plt.axis("off")
    plt.imshow(img2.squeeze(), cmap="gray", vmax=3)
plt.show()

"""Abbiamo sia image, che image_1, che image_2, che image_3.

Concatenazione riuscita correttamente

##2. Splitting
Splittiamo in train-test-vali (80%-10%-10%)
"""

train_image, testing_image = torch.utils.data.random_split(IMAGE, [int(len(IMAGE)*0.8), int(len(IMAGE)*0.2)],generator=torch.Generator().manual_seed(1234))
train_mask, testing_mask = torch.utils.data.random_split(MASK, [int(len(MASK)*0.8), int(len(MASK)*0.2)],generator=torch.Generator().manual_seed(1234))
test_image, vali_image = torch.utils.data.random_split(testing_image, [int(len(testing_image)*0.5), int(len(testing_image)*0.5)],generator=torch.Generator().manual_seed(1234))
test_mask, vali_mask = torch.utils.data.random_split(testing_mask, [int(len(testing_mask)*0.5), int(len(testing_mask)*0.5)],generator=torch.Generator().manual_seed(1234))
print('Training set size: ', len(train_image))
print('Validation set size: ',len(vali_image))
print('Test set size: ',len(test_image))

"""##3. Dataloaders"""

from torch.utils.data import DataLoader
batch_size = 5

train_dl = DataLoader(list(zip(train_image, train_mask)),
                      batch_size=batch_size,
                      shuffle=False,
                      num_workers=1)


vali_dl = DataLoader(list(zip(vali_image, vali_mask)),
                      batch_size=batch_size,
                      shuffle=False,
                      num_workers=1)

test_dl = DataLoader(list(zip(test_image, test_mask)),
                     batch_size=batch_size,
                     shuffle=False,
                     num_workers=1)

"""#U-NET

##Architettura modello
"""

from torch import nn
class UNET(nn.Module):
    def __init__(self, in_channels, out_channels):
        super().__init__()

        self.conv1 = self.contract_block(in_channels, 32, 3, 1)
        self.conv2 = self.contract_block(32, 64, 3, 1)
        self.conv3 = self.contract_block(64, 128, 3, 1)
        self.conv4 = self.contract_block(128, 256, 3, 1)
        self.bottleneck = self.bottleneck_block(256, 256, 3, 1)
        self.upconv4 = self.expand_block(256, 128, 3, 1)
        self.upconv3 = self.expand_block(256, 64, 3, 1)
        self.upconv2 = self.expand_block(128, 32, 3, 1)
        self.upconv1 = self.expand_block(64, out_channels, 3, 1)


    def __call__(self, x):

        # downsampling part
        conv1 = self.conv1(x)
        conv2 = self.conv2(conv1)
        conv3 = self.conv3(conv2)
        conv4 = self.conv4(conv3)

        bottleneck = self.bottleneck(conv4)

        upconv4 = self.upconv4(bottleneck)
        upconv3 = self.upconv3(torch.cat([upconv4, conv3], 1))
        upconv2 = self.upconv2(torch.cat([upconv3, conv2], 1))
        upconv1 = self.upconv1(torch.cat([upconv2, conv1], 1))

        return upconv1

    def contract_block(self, in_channels, out_channels, kernel_size, padding):

        contract = nn.Sequential(
            torch.nn.Conv2d(in_channels, out_channels, kernel_size=kernel_size, stride=1, padding=padding),
            torch.nn.BatchNorm2d(out_channels),
            torch.nn.ReLU(),
            torch.nn.Conv2d(out_channels, out_channels, kernel_size=kernel_size, stride=1, padding=padding),
            torch.nn.BatchNorm2d(out_channels),
            torch.nn.ReLU(),
            torch.nn.MaxPool2d(kernel_size=3, stride=2, padding=1)
                                 )

        return contract

    def expand_block(self, in_channels, out_channels, kernel_size, padding):

        expand = nn.Sequential(torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=padding),
                            torch.nn.BatchNorm2d(out_channels),
                            torch.nn.ReLU(),
                            torch.nn.Conv2d(out_channels, out_channels, kernel_size, stride=1, padding=padding),
                            torch.nn.BatchNorm2d(out_channels),
                            torch.nn.ReLU(),
                            torch.nn.ConvTranspose2d(out_channels, out_channels, kernel_size=3, stride=2, padding=1, output_padding=1)
                            )
        return expand

    def bottleneck_block(self, in_channels, out_channels, kernel_size, padding):

        bottle = nn.Sequential(torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=padding),
                            torch.nn.BatchNorm2d(out_channels),
                            torch.nn.ReLU(),
                            torch.nn.Conv2d(out_channels, out_channels, kernel_size, stride=1, padding=padding),
                            torch.nn.BatchNorm2d(out_channels),
                            torch.nn.ReLU(),
                            torch.nn.ConvTranspose2d(out_channels, out_channels, kernel_size=3, stride=1, padding=1)
                            )
        return bottle

"""##Printout modello"""

model = UNET(1,4)
print(model)

from torchsummary import summary
if torch.cuda.is_available():
  summary(model.cuda(), input_size=(1,512,512))
else:
  summary(model, input_size=(1,512,512))

"""#TRAINING MODELLO"""

model = UNET(1,4)

"""**- IoU metric**


Usiamo come metrica una IoU...

La *Intersection over Union* (*IoU*) è una metrica usata per valutare la performance di un algoritmo di segmentaizone. \\
Date 2 *masks* $y_{true}$ ed $y_{pred}$ valutiamo:

$$IoU = \frac{y_{true} \cap y_{pred}}{y_{true} \cup y_{pred}}$$

Nota:

    
        se IoU > 0.5 → decent
        se IoU > 0.7 → pretty good
        se IoU > 0.9 → very good



![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAdQAAAE4CAIAAABtw5XCAAABaWlDQ1BrQ0dDb2xvclNwYWNlSVRVUl83MDkAACiRY2Bg0kksKMhhYWBgyM0rKQpyd1KIiIxSYL/PwMUgCRSUZZBJTC4ucAwI8AHyGGA0Kvh2jYERRF/WBZl1eIZZ1ASmvNX2Dz/6BP02W4CpHgVwpaQWJwPpP0Ccl1xQVMLAwJgDZCuXlxSA2BOAbJEioKOA7CUgdjqEvQPEToKwz4DVhAQ5A9kPgGyF5IzEFAYGJpD5OklI4ulIbKi9ICASlJqsp+AZEqobpOAUomduYKlrSsDZpIOS1IoSEO2cX1BZlJmeUaLgCAytVAXPvGQ9HQUjA0OglaCwh6j+HAgOU0axMwix/EUMDBZfGRiYJyDEkmYyMGxvZWCQuIUQU1nAwMDfwsCw7XxBYlEiWIgZiJksnjAwvPjAwCAuADQHyBbZU5xmbASWZ+RxYmBgvff//2c1Bgb2yQwMfyf8//970f//fxcDNd9hYDiQBwBuoWawaYK3pAAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAB1KADAAQAAAABAAABOAAAAABW4NuaAABAAElEQVR4AezdB4AtRZno8Zk5c2bm3guXLAiiBJHgCq6gPEFYVDC7BkSfkWB6uurTNSAi6LrmvPjMEV1U1gBGMGLCnAOCARRBQHK4d/LM+1V/Mz3nnsl3zsycc26V16K6+quvqr6e/vd3vu6u7hwfH+/IKVtgpSxQ+/fW2dm5Ut3mfrIFms4C3U03ojygdrdAZm67H+E8vwVZoLPWE1lQiyyULZAtkC2QLbBkC3QtWUNWkC2QLZAtkC2waAvksMOiTZYbzGGB8odUji3MYaW8K1uABbLnm/8MGmaBkryL1bjZDRfbUZbPFmgeC2TPt3mOxRY0koXTdjbJ7FlvQX8ubTrV7Pm26YFt1mmB6XSeTq9p1uHncWULNMwCGb4NM+UWq2hoaGhsbMz05TDa398fbuno6KhK+caNGxUGBgbsrd2lbNfIyIhCCA8ODgaIbdIWmu2VaAjJW2+9NTZJ1iYCOWULtJAF8qNmLXSwmnGow8PD3d3daBjkjSGCZldXl3q47O3tVXnLLbesX7+ecLVaRUzClUoFptesWWOvekmZnrIt/pKxl3xZDuzapD/6KvPYVW7mQrZAk1ug/i+4yYebh9dsFgBT3ATZkoZBTORVQMnwXrfeemuoJRyMtosjjLYEeLu4uXbtWnowuqenxxwJU0hYWWVwnFg40ZHXmiKTt9YaudwSFsieb0scpuYdJHTybcE3nFOUFBaAWty0C17BN3iKthCpHKCE2g0bNmy77bYxNzzF36CtnB7ysame5Lp166ILjjAN8tIombylKXKhhSyQPd8WOljNOFTkhVesDAQbYhBTIfxctCUAxH19fWpCgGOrSZAXdpE0ohMwGh70zTffTJ4M8torR97QTB7rS/hm8jbjn0Ue0wIskOG7ACNlkTktEHEGPAVQTNxmm23i3hqMSmowFIKhEygjQKEgBXbDF7aXpMqgqgBxGcqAXfjWC3YryCk0opCcc2h5Z7ZA81ogw7d5j01LjEz0IGK7cbtszz33BNCddtpJ5GH//fd/97vfjaEB1vPPP/+www7j7e68887HHnvsj370IxjlEZ955pl77703dlNlyhdeeOGd7nSnv/71rxqCrCCGHMTtevrTn/6mN70JrAln8rbEn0ce5FwW8EecU7bAEi0Ar9DJLd1nn31AFje5q9/5zncQ+bLLLqP8rLPOQuTPfvazJO0C3O233/773/++XVo97nGPg2Nlwrvvvvs3vvEN2myGawzQl1xyycMe9jCBiFe96lXqpegisB41Oc8WaC0L5Dfc5roy5X0LsQBQck4lVL3pppsEHziqylipvOOOOzolTjnllP/6r/965CMfqZ7k4x//+GuvvfblL3/5eeedR/ijH/3oAQcc8Ja3vOXTn/70S1/60iOOOEK/WmE3yHJ13/nOd2qy3377KWOxJhE+jpMtBsnjXshos0y2QJNYYJO7xk0ypjyMlrMADxQTsXKvvfa67rrrwJE/Kzjw6le/+uSTT/7jH/+IrTfeeKNYhBhFxBN+/etfH3TQQegZk7344ottcm8/9alPlZV2kef/uuGm/IxnPGO33XZ7xStegeC6qLVSJm+tNXK5JSywyV9wS4w4D7KpLMDtDRQiLwQD67nnnnvllVci5o9//ON3vetdn/vc53bddVdjjtAwGZ6vTQK8V20lrb773e96mOxb3/qWIC9JMJUUbrvtNuSFck340YIVCnZln5cdcmppC2T4tvThW/3Bx00z44jwayAYRtUccsgh97vf/S644AKx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VrSS4k1rGDIqQwImu972trc96lGPes973vPCF75QvVYGTEaheHEusSw0WKhTL2Rgjkzsjb5CvyZr1661K14yTFPuSusLa/Wud73rN7/5zR577JGmX6kYiYJhE4gpqzQkfLdLjYLuqCJAz5577vnlL385pkAhmVox8tFpwvDoqGFoTpu2YZmoNFQFlV4LfO973/v973//n/7pn7RVb47kYyTz5hMjnlcuC2QLZAuslAXg0YlZPCU2+dDCmp7eUauYjVjWIb1t3F3pqvJ8uzqqnZ0//+mPP/Hf//3zn/20e6u1R9znsPQFitGRcSsA+zeObtagnEoAIRUT4Q4Xr2UUBIaSoBtCWcRi663WRQ2aqEEr3muxqxuSNFQmr57qgNQXv/jFU045Zeutt/7EJz6BSupf/epXP/axj91pp52OO+44iHzDG95w8MEHH3HEEY9+9KOvuuoqSj7/+c/f//73v+c972nR5De+8Y0GBp0wp629F1544YEHHnjIIYfIzznnHIx+zGMeo8cHPvCBP/zhD4kF5rCVvNFqrl+VCjE8Mv/5n/9J/rDDDnvnO9+p/ve//70rRIzfaO9xj3vc5S53edKTnoS5lFi4+dRTTz322GPvete7fvCDH9SXqaHzhg0btP3e97530EEHGS3UfuYzn1FPkhGe9rSnXXDBBbfccotOF05eY8ieLyPklC3Q7BYIrPh6fG9P9y233GztXWT59gXf+eXPflitVizN4O2K3fc94HY77LBhQ38PB9a6D2kJ9pQUijy5fiDixtqYVdWxOVUXbyGPjVvP7LprrwEguOFEJsiPpQ8pRYtwD+kJ2uKg8lZbbRU1VH70ox/dZZddsAlnYQ7O7ALE3/72t5dddpnC+973PgX84tL+v//3//793//9Yx/7GOB+/OMfv/3tb3/NNdcg2jOe8Yz169cbA/033ngjVZ/+9Kfvc5/7XHrppfe+971R8nOf+9wOO+zA05QbiX6ZRUeSVsBt8Opvu+02I6cECgUZXvOa11x88cWHHnroCSecoEk4xaeffvqf//xnfDcLQYznPe95fHZK+NTk7cJfs0B22sjI//Vf//X888+/173uZe/hhx9O4Atf+IIYiAvDbrvtBt+SMSD1unXrYlRz5xm+c9sn780WWFELxJcsCs+37Df9PEWBm2666XY77XDzTTfsuN324gzvfevb+L2J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)
"""

!pip install torchmetrics

#Checkpoint per salvare il modello durante il training (solo il best model)
class SaveBestModel:
    def __init__(self, best_valid_loss=float('inf')): #object initialized with best_loss = +infinite
        self.best_valid_loss = best_valid_loss

    def __call__(
        self, current_valid_loss,
        epoch, model, optimizer, criterion, metric,
    ):
        if current_valid_loss < self.best_valid_loss:
            self.best_valid_loss = current_valid_loss
            print(f"\nBest validation loss: {self.best_valid_loss}")
            print(f"\nSaving best model for epoch: {epoch+1}\n")
            # method to save a model (the state_dict: a python dictionary object that
            # maps each layer to its parameter tensor) and other useful parametrers
            # see: https://pytorch.org/tutorials/beginner/saving_loading_models.html
            torch.save({'model' : model,
                'epoch': epoch+1,
                'model_state_dict': model.state_dict(),
                'optimizer_state_dict': optimizer.state_dict(),
                'loss': criterion,
                'metric': metric,
                }, 'best_model.pt')

import time
from IPython.display import clear_output
from torchmetrics import JaccardIndex

#metrica Iou
Iou=JaccardIndex(num_classes=4).cuda()

save_best_model = SaveBestModel()

def train(model, train_dl, valid_dl, loss_fn, optimizer, acc_fn, epochs=1):
    start = time.time()
    model.cuda()

    train_loss, valid_loss, train_acc, valid_acc = [], [], [], []

    best_acc = 0.0

    for epoch in range(epochs):
        print('Epoch {}/{}'.format(epoch, epochs - 1))
        print('-' * 10)

        for phase in ['train', 'valid']:
            if phase == 'train':
                model.train(True)  # Set trainind mode = true
                dataloader = train_dl
            else:
                model.train(False)  # Set model to evaluate mode
                dataloader = valid_dl

            running_loss = 0.0
            running_acc = 0.0

            step = 0

            # iterate over data
            for x, y in dataloader:
                x = (x*256).cuda()
                #NOTA: moltiplichiamo per 256 perché nella trasformazione a ToTensor avviene una rinormalizzazione tra [0,1]
                #tuttavia questo compatta eccessivamente i possibili valori che assume il dataloader
                #e che vengono dunque letti tutti come zeri, producendo solo immagini nere.
                #Con questa spaziatura ripristiniamo la scala di grigi originaria [0,256] e l'analisi è possibile.

                y =  y.type(torch.long).cuda()
                #NOTA: la CrossEntropyLoss funziona solo per Torch.long, tuttavia y, essendo acquisito come un tensore torch.float32,
                #è normalizzato nuovamente a [0,1] e di questo ci siamo occupati nel blocco "Concatenazione",
                #per riportarlo in scala [0,3]. Non è stato possibile trasformarlo in un torch.long64
                #perché, viste le dimensioni eccessive, si aveva un problema con la RAM.

                step += 1

                # forward pass
                if phase == 'train':
                    # zero the gradients
                    optimizer.zero_grad()
                    outputs = model(x)
                    loss = loss_fn(outputs, y)

                    # the backward pass frees the graph memory, so there is no
                    # need for torch.no_grad in this training pass
                    loss.backward()
                    optimizer.step()
                    # scheduler.step()

                else:
                    with torch.no_grad():
                        outputs = model(x)
                        loss = loss_fn(outputs, y.long())

                # stats - whatever is the phase
                acc = acc_fn(outputs, y)

                running_acc  += acc*dataloader.batch_size
                running_loss += loss.detach()*dataloader.batch_size

                if step % 100 == 0:
                    # clear_output(wait=True)
                    print('Current step: {}  Loss: {}  Acc: {}  AllocMem (Mb): {}'.format(step, loss, acc, torch.cuda.memory_allocated()/1024/1024))
                    # print(torch.cuda.memory_summary())

            epoch_loss = running_loss / len(dataloader.dataset)
            epoch_acc = running_acc / len(dataloader.dataset)

            clear_output(wait=True)
            print('Epoch {}/{}'.format(epoch, epochs - 1))
            print('-' * 10)
            print('{} Loss: {:.4f} Acc: {}'.format(phase, epoch_loss, epoch_acc))
            print('-' * 10)

            train_loss.append(epoch_loss) if phase=='train' else valid_loss.append(epoch_loss)
            train_acc.append(epoch_acc) if phase=='train' else valid_acc.append(epoch_acc)

            #save best model
            if phase=='train':
              save_best_model(epoch_loss, epoch, model, optimizer, loss_fn, Iou)

            time_elapsed = time.time() - start
            print('Training complete in {:.0f}m {:.0f}s'.format(time_elapsed // 60, time_elapsed % 60))

    return train_loss, valid_loss, train_acc, valid_acc

def acc_metric(predb, yb):
    #return (predb.argmax(dim=1) == yb.cuda()).float().mean()

    return (Iou(predb,yb))

pesi = torch.tensor([1.,1.,10.,10.]).to('cuda')
loss_fn = nn.CrossEntropyLoss(weight=pesi)
opt = torch.optim.Adam(model.parameters(), lr=0.001)
train_loss, valid_loss, train_acc, valid_acc = train(model, train_dl, vali_dl, loss_fn, opt, acc_metric, epochs=30)

"""**NOTA:**

Passiamo alla *CrossEntropyLoss* un tensore di pesi, in cui diamo maggiore importanza ai valori relativa a zone infette (*glass opacity* e *consolidation*).

In questo modo abbiamo migliore rappresentazione dell'effettiva precisione del nostro modello ed evitiamo *overfitting* in zone poco interessanti.

##Plotting

###Andamento *loss* e *IoU*
"""

plt.figure(figsize=(18, 7))

#LOSS
plt.subplot(1,2,1)
plt.plot([item.cpu() for item in train_loss], label='Train loss', color='red')
plt.plot([item.cpu() for item in valid_loss], label='Valid loss', color='blue')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.title('ANDAMENTO DELLA LOSS ALLE VARIE EPOCHE')
plt.legend()

#IoU
plt.subplot(1,2,2)
plt.plot([item.cpu() for item in train_acc], label='Train IoU', color='red')
plt.plot([item.cpu() for item in valid_acc], label='Valid IoU', color='blue')
plt.xlabel('Epochs')
plt.ylabel('IoU')
plt.title('ANDAMENTO DELLA IoU ALLE VARIE EPOCHE')
plt.legend()

plt.tight_layout()
plt.show()

"""###Showing some results"""

def batch_to_img(xb, idx):
    img = np.array(xb[idx,0:3])
    return img.transpose((1,2,0))

def predb_to_mask(predb, idx):
    p = torch.functional.F.softmax(predb[idx], 0)
    return p.argmax(0).cpu()

xb, yb = next(iter(train_dl))

with torch.no_grad():
    predb = model((xb*256).cuda())

predb.shape

bs = 4
fig, ax = plt.subplots(bs,3, figsize=(13,bs*5))

for i in range(bs):
    ax[0,0].set_title("Original CT image")
    ax[i,0].imshow(batch_to_img(xb,i).squeeze(), cmap="gray", vmax=1)
    ax[i,0].set_axis_off()

    ax[0,1].set_title("Ground truth mask")
    ax[i,1].imshow(yb[i].squeeze(), cmap="gray", vmax=3)
    ax[i,1].set_axis_off()

    ax[0,2].set_title("Predicted mask")
    ax[i,2].imshow(predb_to_mask(predb, i).squeeze(), cmap="gray", vmax=3)
    ax[i,2].set_axis_off()

#plt.tight_layout()
plt.show()

"""#TEST"""

#Test set perfromance

# lettura del modello
model_data = torch.load('./best_model.pt')
print('Best model at epoch: ', model_data['epoch'])
model = model_data['model']
model.eval() #va sempre fatto per settare eventuali layer di droput e batch norm in evaluation model

# Non è strettamento necessario girare sulla GPU per l'inferenza (non richiede grande potenza di calcolo)
#model.to(torch.device('cpu'))

loss = 0
metric = 0
counter = 0

for xb, yb in test_dl:
  counter += 1
  xb=(xb*256).cuda()
  yb=(yb.type(torch.long)).cuda()
  pred = model(xb)


  loss += loss_fn(pred, yb).item()
  metric += Iou(pred, yb).item()


loss /= counter
metric /= counter

print('Test loss:', loss, 'Test Accuracy (IoU):', metric)